import pickle
from pathlib import Path
import numpy as np
import pandas as pd
from scipy.signal import welch
from sklearn.metrics import roc_curve, accuracy_score, f1_score, confusion_matrix


EPOCHS_DIR = Path(r"C:\Users\jsmoo\PycharmProjects\pythonProject23\data\epochs")
RESULTS_DIR = Path(r"C:\Users\jsmoo\PycharmProjects\pythonProject23\data\cpsd_transition_results_final")
RESULTS_DIR.mkdir(exist_ok=True, parents=True)


beta_band = (13, 30)
gamma_band = (30, 70)
motor_channels = ["C3..", "Cz..", "C4..", "C1..", "C2..", "CP3.", "CPz.", "CP4.", "FC3.", "FCz.", "FC4."]
non_motor_channels = [
    "Fz..", "F3..", "F4..", "F1..", "F2..", "AF3.", "AFz.", "AF4.", "Fp1.", "Fpz.", "Fp2.",
    "Pz..", "P3..", "P4..", "P1..", "P2..", "POz.", "Po3.", "Po4.",
    "Oz..", "O1..", "O2..", "Iz..", "T7..", "T8..", "T9..", "T10.", "Tp7.", "Tp8.",
    "FCz.", "CPz.", "Poz."
]

task_info_map = {
    3:  ("Task1", "left_fist",  "right_fist"),
    4:  ("Task2", "left_fist",  "right_fist"),
    5:  ("Task3", "both_fists", "both_feet"),
    6:  ("Task4", "both_fists", "both_feet"),
    7:  ("Task1", "left_fist",  "right_fist"),
    8:  ("Task2", "left_fist",  "right_fist"),
    9:  ("Task3", "both_fists", "both_feet"),
    10: ("Task4", "both_fists", "both_feet"),
    11: ("Task1", "left_fist",  "right_fist"),
    12: ("Task2", "left_fist",  "right_fist"),
    13: ("Task3", "both_fists", "both_feet"),
    14: ("Task4", "both_fists", "both_feet"),
}

#  window size (sliding) 
min_size = 0.05
max_size = 1.0
size_step = 0.05
window_sizes = np.arange(min_size, max_size + 1e-6, size_step)
t_start, t_end = -1.5, 0.0
slide_step = 0.05

def get_cpsd_arr(X, ch_names, times, window, chans, band, fs):
    mask = (times >= window[0]) & (times < window[1])
    arr = []
    win_len = np.sum(mask)
    _nperseg = min(128, win_len)
    for i in range(X.shape[0]):
        v = 0
        for idx in [ii for ii, c in enumerate(ch_names) if c in chans]:
            f, Pxx = welch(X[i, idx, mask], fs=fs, nperseg=_nperseg)
            v += np.sum(Pxx[(f >= band[0]) & (f < band[1])])
        v /= len([ii for ii, c in enumerate(ch_names) if c in chans])
        arr.append(v)
    return np.array(arr)

def find_optimal_thresh(feature, label, pos_value):
    if np.unique(label).size < 2:
        return np.nan, np.nan, np.nan, None, None
    fpr, tpr, thresh = roc_curve(label == pos_value, feature)
    j_scores = tpr - fpr
    ix = np.argmax(j_scores)
    best_thresh = thresh[ix]
    preds = (feature >= best_thresh).astype(int)
    acc = accuracy_score(label == pos_value, preds)
    f1 = f1_score(label == pos_value, preds)
    cm = confusion_matrix(label == pos_value, preds)
    return best_thresh, acc, f1, cm, preds

def get_run_number(filename):
    import re
    m = re.search(r'R(\d{2})', filename)
    if m:
        return int(m.group(1))
    return None

def extract_transitions(events):
    transitions = []
    labels = events[:,2]
    for i in range(1, len(labels)):
        prev, curr = labels[i-1], labels[i]
        if prev == 1 and curr == 2:
            transitions.append(('T0_T1', i-1, i))
        elif prev == 1 and curr == 3:
            transitions.append(('T0_T2', i-1, i))
        elif prev == 2 and curr == 1:
            transitions.append(('T1_T0', i-1, i))
        elif prev == 3 and curr == 1:
            transitions.append(('T2_T0', i-1, i))
    return transitions

for subj_dir in sorted(EPOCHS_DIR.iterdir()):
    if not subj_dir.is_dir() or not subj_dir.name.startswith('S'):
        continue
    subj = subj_dir.name

    for epochs_file in sorted(subj_dir.glob("*epochs.pkl")):
        run_num = get_run_number(epochs_file.name)
        if run_num not in task_info_map:
            continue
        task, _, _ = task_info_map[run_num]

        with open(epochs_file, "rb") as f:
            data = pickle.load(f)
        epochs = data["epochs"]
        X = epochs.get_data()
        times = epochs.times
        ch_names = epochs.ch_names
        events = epochs.events
        fs = epochs.info['sfreq']

        transitions = extract_transitions(events)

        for transition_name in ['T0_T1', 'T0_T2', 'T1_T0', 'T2_T0']:
            for band_label, (band, chans) in [('beta', (beta_band, motor_channels)), ('gamma', (gamma_band, non_motor_channels))]:
                best_acc, best_f1, best_win, best_thresh = 0, 0, None, None
                for transition, idx1, idx2 in transitions:
                    if transition != transition_name:
                        continue

                    label_map = {
                        'T0_T1': (1,2), 'T0_T2': (1,3),
                        'T1_T0': (2,1), 'T2_T0': (3,1)
                    }
                    label_from, label_to = label_map[transition]
                    mask = (events[:,2] == label_from) | (events[:,2] == label_to)
                    labels_tr = events[mask,2]
                    X_tr = X[mask]
                    y_tr = (labels_tr == label_to).astype(int)

                    for ws in window_sizes:
                        slide_positions = np.arange(t_start, t_end-ws+1e-6, slide_step)
                        for st in slide_positions:
                            ed = st + ws
                            cpsd = get_cpsd_arr(X_tr, ch_names, times, (st, ed), chans, band, fs)
                            thresh, acc, f1, cm, preds = find_optimal_thresh(cpsd, y_tr, 1)
                            if acc > best_acc:
                                best_acc, best_f1, best_win, best_thresh = acc, f1, (st, ed, ws), thresh

                if best_acc > 0:
                    arrow = {
                        'T0_T1': "[T0→T1]", 'T0_T2': "[T0→T2]",
                        'T1_T0': "[T1→T0]", 'T2_T0': "[T2→T0]"
                    }[transition_name]

                    save_dir = RESULTS_DIR / subj
                    save_dir.mkdir(exist_ok=True, parents=True)
                    save_file = save_dir / f"{subj}_R{str(run_num).zfill(2)}_{task}_{band_label}.csv"
                    result = {
                        "subject": subj,
                        "run": run_num,
                        "task": task,
                        "band": band_label,
                        "transition": transition_name,
                        "acc": best_acc,
                        "f1": best_f1,
                        "win_start": best_win[0],
                        "win_end": best_win[1],
                        "win_size": best_win[2],
                        "threshold": best_thresh
                    }
                    df_row = pd.DataFrame([result])
                    if save_file.exists():
                        df_old = pd.read_csv(save_file)
                        df_combined = pd.concat([df_old, df_row], ignore_index=True)
                    else:
                        df_combined = df_row
                    df_combined.to_csv(save_file, index=False)

                    print(f"{subj} | {task} (Run{run_num}) [{band_label}]\n    {arrow} acc={best_acc:.2f}, F1={best_f1:.2f}, window={best_win[0]:.2f}~{best_win[1]:.2f}, winlen={best_win[2]:.2f}, threshold={best_thresh:.4f}")
